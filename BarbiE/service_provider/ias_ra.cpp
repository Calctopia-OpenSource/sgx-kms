/*
 * Copyright (C) 2011-2016 Intel Corporation. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in
 *     the documentation and/or other materials provided with the
 *     distribution.
 *   * Neither the name of Intel Corporation nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */



#include "service_provider.h"
#include "sample_libcrypto.h"
#include "ecp.h"
#include "Base64.h"
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <time.h>
#include <string.h>
#include "ias_ra.h"
#include <limits.h>
#include <unistd.h>
#include <curl/curl.h>
#include <jsoncpp/json/json.h>
#include <stdint.h>
#include <assert.h>
#include<string>
#include <vector>
#include <fstream>
#include <jsoncpp/json/writer.h>
using namespace std;


// @TODO: This whole file is used as simulation of the interfaces to be
// delivered the IAS. Once the interface definitions are made available by the
// IAS, this file should be changed accordingly.

#define UNUSED(expr) do { (void)(expr); } while (0)

#if !defined(SWAP_ENDIAN_DW)
    #define SWAP_ENDIAN_DW(dw)	((((dw) & 0x000000ff) << 24)                \
    | (((dw) & 0x0000ff00) << 8)                                            \
    | (((dw) & 0x00ff0000) >> 8)                                            \
    | (((dw) & 0xff000000) >> 24))
#endif
#if !defined(SWAP_ENDIAN_32B)
    #define SWAP_ENDIAN_32B(ptr)                                            \
{\
    unsigned int temp = 0;                                                  \
    temp = SWAP_ENDIAN_DW(((unsigned int*)(ptr))[0]);                       \
    ((unsigned int*)(ptr))[0] = SWAP_ENDIAN_DW(((unsigned int*)(ptr))[7]);  \
    ((unsigned int*)(ptr))[7] = temp;                                       \
    temp = SWAP_ENDIAN_DW(((unsigned int*)(ptr))[1]);                       \
    ((unsigned int*)(ptr))[1] = SWAP_ENDIAN_DW(((unsigned int*)(ptr))[6]);  \
    ((unsigned int*)(ptr))[6] = temp;                                       \
    temp = SWAP_ENDIAN_DW(((unsigned int*)(ptr))[2]);                       \
    ((unsigned int*)(ptr))[2] = SWAP_ENDIAN_DW(((unsigned int*)(ptr))[5]);  \
    ((unsigned int*)(ptr))[5] = temp;                                       \
    temp = SWAP_ENDIAN_DW(((unsigned int*)(ptr))[3]);                       \
    ((unsigned int*)(ptr))[3] = SWAP_ENDIAN_DW(((unsigned int*)(ptr))[4]);  \
    ((unsigned int*)(ptr))[4] = temp;                                       \
}
#endif

// This is the ECDSA NIST P-256 private key used to sign platform_info_blob.
// This private
// key and the public key in SDK untrusted KElibrary should be a temporary key
// pair. For production parts the IAS will sign the platform_info_blob with the
// production private key and the SDK untrusted KE library will have the public
// key for verifcation.
// @TODO:  This key will will not be available when the production backend
// is avaialbe.  The remote attestation sample will need to change to use the
// real backend. This will likely be an RSA2048 type of key.
static const sample_ec256_private_t g_rk_priv_key =
{{
    0x63,0x2c,0xd4,0x02,0x7a,0xdc,0x56,0xa5,
    0x59,0x6c,0x44,0x3e,0x43,0xca,0x4e,0x0b,
    0x58,0xcd,0x78,0xcb,0x3c,0x7e,0xd5,0xb9,
    0xf2,0x91,0x5b,0x39,0x0d,0xb3,0xb5,0xfb
}};


// Simulates the IAS function for verifying the quote produce by
// the ISV enclave. It doesn't decrypt or verify the quote in
// the simulation.  Just produces the attestaion verification
// report with the platform info blob.
//
// @param p_isv_quote Pointer to the quote generated by the ISV
//                    enclave.
// @param pse_manifest Pointer to the PSE manifest if used.
// @param p_attestation_verification_report Pointer the outputed
//                                          verification report.
//
// @return int

static int REQUEST_ID_MAX_LEN = 32;

struct ias_response_container_t {
    char *p_response;
    size_t size;
};

struct ias_response_header_t {
    int response_status;
    int content_length;
    char *request_id;
    char *iasreport_signature;
    char *iasreport_signing_certificate;
};

size_t ias_response_header_parser(void *ptr, size_t size, size_t nmemb, void *userdata) {

    int parsed_fields = 0, response_status, content_length, ret = size * nmemb;
    char *x = (char*) calloc(size+1, nmemb);
    assert(x);
    memcpy(x, ptr, size * nmemb);
    parsed_fields = sscanf( x, "HTTP/1.1 %d", &response_status );

    if (parsed_fields == 1) {
        ((ias_response_header_t *) userdata)->response_status = response_status;
        return ret;
    }

    parsed_fields = sscanf( x, "content-length: %d", &content_length );
    if (parsed_fields == 1) {
        ((ias_response_header_t *) userdata)->content_length = content_length;
        return ret;
    }

    char *p_request_id = (char*) calloc(1, REQUEST_ID_MAX_LEN);
    parsed_fields = sscanf(x, "request-id: %s", p_request_id );

    if (parsed_fields == 1) {
        ( ( ias_response_header_t * ) userdata )->request_id = p_request_id;
        return ret;
    }
    char *iasreport_signature = (char*) calloc(500, sizeof(char));
    parsed_fields = sscanf(x, "x-iasreport-signature: %s", iasreport_signature );

    if (parsed_fields == 1) {
        ( ( ias_response_header_t * ) userdata )->iasreport_signature = iasreport_signature;
        return ret;
    }
    char *iasreport_signing_certificate = (char*) calloc(4000, sizeof(char));
    parsed_fields = sscanf(x, "x-iasreport-signing-certificate: %s", iasreport_signing_certificate);

    if (parsed_fields == 1) {
        ( ( ias_response_header_t * ) userdata )->iasreport_signing_certificate = iasreport_signing_certificate;
        return ret;
    }

    return ret;
}

char* find_and_replace(char *str, char *find, char *replace)
{
    static char *buffer;
	buffer = (char *)calloc(strlen(str), sizeof(char));
    char *p;
    int i = 0;

    if (!(p = strstr(str + i, find)))
    {
        return str;
    }

    while (str[i])
    {
        if (!(p = strstr(str + i, find)))
        {
            strcat(buffer, str + i);
            break; //return str;
        }
        strncpy(buffer + strlen(buffer), str + i, (p - str) - i);
        buffer[p - str] = '\0';
        strcat(buffer, replace);
        i = (p - str) + strlen(find);
    }
    free(str);
    str=NULL;
    return buffer;
}

char* decode_crt(char *crt_str){
    char *final_str = NULL;
    final_str = find_and_replace(crt_str, "%20C"," C");
    final_str = find_and_replace(final_str, "%0A", "\n");
    final_str = find_and_replace(final_str, "%2B", "+");
    final_str = find_and_replace(final_str, "%3D", "=");

    return final_str;
}

size_t ias_reponse_body_handler( void *ptr, size_t size, size_t nmemb, void *userdata ) {

    size_t realsize = size * nmemb;
    ias_response_container_t *ias_response_container = ( ias_response_container_t * ) userdata;
    ias_response_container->p_response = (char *) realloc(ias_response_container->p_response, ias_response_container->size + realsize + 1);

    if (ias_response_container->p_response == NULL ) {
        return 0;
    }

    memcpy( &( ias_response_container->p_response[ias_response_container->size]), ptr, realsize );
    ias_response_container->size += realsize;
    ias_response_container->p_response[ias_response_container->size] = 0;

    return realsize;
}

bool sendToIAS(string url,
               string payload,
               struct curl_slist *headers,
               ias_response_container_t *ias_response_container,
               ias_response_header_t *response_header,
               uint8_t *ias_crt) {

    CURLcode res = CURLE_OK;
    curl_global_init(CURL_GLOBAL_DEFAULT);
    CURL *curl = curl_easy_init();
    char *ias_crt_path;
    ias_crt_path = (char *)ias_crt;
    curl_easy_setopt( curl, CURLOPT_SSLCERTTYPE, "PEM");
    curl_easy_setopt( curl, CURLOPT_SSLCERT, ias_crt_path);
    curl_easy_setopt( curl, CURLOPT_USE_SSL, CURLUSESSL_ALL);
    curl_easy_setopt( curl, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2);
    curl_easy_setopt( curl, CURLOPT_NOPROGRESS, 1L);

    curl_easy_setopt( curl, CURLOPT_URL, url.c_str());

    if (headers) {
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload.c_str());
    }

    ias_response_container->p_response = (char*) malloc(1);
    ias_response_container->size = 0;

    curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, ias_response_header_parser);
    curl_easy_setopt(curl, CURLOPT_HEADERDATA, response_header);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, ias_reponse_body_handler);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, ias_response_container);

    res = curl_easy_perform(curl);
    if (res != CURLE_OK) {
        fprintf(stderr, "\nError, Curl response: Failed");
        return false;
    }

    return true;
}

vector<pair<string, string> > parseJSONfromIAS(string json) {

    Json::Value root;
    Json::Reader reader;
    bool parsingSuccessful = reader.parse(json.c_str(), root);

    if (!parsingSuccessful) {
        return vector<pair<string, string> >();
    }

    vector<pair<string,string> > values;

    string id = root.get("id", "UTF-8" ).asString();
    string timestamp = root.get("timestamp", "UTF-8" ).asString();
    string epidPseudonym = root.get("epidPseudonym", "UTF-8" ).asString();
    string isvEnclaveQuoteStatus = root.get("isvEnclaveQuoteStatus", "UTF-8" ).asString();

    values.push_back({"id", id});
    values.push_back({"timestamp", timestamp});
    values.push_back({"epidPseudonym", epidPseudonym});
    values.push_back({"isvEnclaveQuoteStatus", isvEnclaveQuoteStatus});

    return values;
}

bool verifyQuote(uint8_t *quote, vector<pair<string, string> > *result, uint8_t *ias_crt, uint8_t *resp_crt, uint8_t *resp_sign, uint8_t *resp_body){
    Json::Value request;
    ias_response_container_t ias_response_container;
    ias_response_header_t response_header;
    //Creating Payload for IAS call
    request["isvEnclaveQuote"] = base64_encode(quote, 1116);
    Json::FastWriter fastWriter;
    string encoded_quote = fastWriter.write(request);
    string payload = encoded_quote;
    //Creating Headers for IAS call
    struct curl_slist *headers = NULL;
    headers = curl_slist_append(headers, "Content-Type: application/json");

    string url;
    if(NULL != getenv("IAS_URL")) {
         url = getenv("IAS_URL");
    } else {
            fprintf(stderr, "\nError, IAS_URL not set in env.properties file. Please refer /opt/BarbiE/env.properties file");
            return false;
        }
    if(sendToIAS(url, payload, headers, &ias_response_container, &response_header, ias_crt)){

        if(resp_crt  && resp_sign  && resp_body && \
           response_header.iasreport_signature &&  \
           response_header.iasreport_signing_certificate && \
           ias_response_container.p_response){

            strcpy((char *)resp_sign, response_header.iasreport_signature);
            strcpy((char *)resp_crt, decode_crt(response_header.iasreport_signing_certificate));
            strcpy((char *)resp_body, ias_response_container.p_response);
        }
        if (response_header.response_status == 201) {
            string response(ias_response_container.p_response);
            *result = parseJSONfromIAS(response);
            return true;
        } else {
              fprintf(stderr, "\nError, Quote attestation returned status: %d", response_header.response_status);
              return false;
          }
    }
    return false;
}

int ias_verify_attestation_evidence(
    uint8_t *p_isv_quote,
    uint8_t* pse_manifest,
    ias_att_report_t* p_attestation_verification_report, uint8_t *ias_crt,
    uint8_t  *resp_crt, uint8_t *resp_sign, uint8_t *resp_body, bool fake_report)
{

    int ret = 0;
    sample_ecc_state_handle_t ecc_state = NULL;

    //unused parameters
    UNUSED(pse_manifest);

    if((NULL == p_isv_quote) ||
        (NULL == p_attestation_verification_report))
    {
        return -1;
    }
    if(!fake_report){
        //Decrypt the Quote signature and verify.
        string report_id;
        ias_quote_status_t quoteStatus;
        string timestamp, epidPseudonym, isvEnclaveQuoteStatus;
        vector<pair<string, string>> result;
        if(!verifyQuote(p_isv_quote, &result, ias_crt, resp_crt, resp_sign, resp_body)) {
            return -1;
        }

        for (auto x : result) {
            if (x.first == "id") {
                report_id = x.second;
            } else if (x.first == "timestamp") {
                timestamp = x.second;
            } else if (x.first == "epidPseudonym") {
                epidPseudonym = x.second;
            } else if (x.first == "isvEnclaveQuoteStatus") {
                if (x.second == "OK")
                    quoteStatus = IAS_QUOTE_OK;
                else if (x.second == "SIGNATURE_INVALID")
                    quoteStatus = IAS_QUOTE_SIGNATURE_INVALID;
                else if (x.second == "GROUP_REVOKED")
                    quoteStatus = IAS_QUOTE_GROUP_REVOKED;
                else if (x.second == "SIGNATURE_REVOKED")
                    quoteStatus = IAS_QUOTE_SIGNATURE_REVOKED;
                else if (x.second == "KEY_REVOKED")
                    quoteStatus = IAS_QUOTE_KEY_REVOKED;
                else if (x.second == "SIGRL_VERSION_MISMATCH")
                    quoteStatus = IAS_QUOTE_SIGRL_VERSION_MISMATCH;
                else if (x.second == "GROUP_OUT_OF_DATE")
                    quoteStatus = IAS_QUOTE_OK;    //TODO Just for testing as we are receiving QUOTE_OUT_OF_DATE
            }
        }


        report_id.copy(p_attestation_verification_report->id, report_id.size());
        p_attestation_verification_report->status = quoteStatus;
        p_attestation_verification_report->revocation_reason = IAS_REVOC_REASON_NONE;
    }
    else {
        strncpy(p_attestation_verification_report->id, "12345678", 8);
        p_attestation_verification_report->status = IAS_QUOTE_OK;
        p_attestation_verification_report->revocation_reason = IAS_REVOC_REASON_NONE;
    }
    p_attestation_verification_report->info_blob.sample_epid_group_status =
        0 << IAS_EPID_GROUP_STATUS_REVOKED_BIT_POS
        | 0 << IAS_EPID_GROUP_STATUS_REKEY_AVAILABLE_BIT_POS;
    p_attestation_verification_report->info_blob.sample_tcb_evaluation_status =
        0 << IAS_TCB_EVAL_STATUS_CPUSVN_OUT_OF_DATE_BIT_POS
        | 0 << IAS_TCB_EVAL_STATUS_ISVSVN_OUT_OF_DATE_BIT_POS;
    p_attestation_verification_report->info_blob.pse_evaluation_status =
        0 << IAS_PSE_EVAL_STATUS_ISVSVN_OUT_OF_DATE_BIT_POS
        | 0 << IAS_PSE_EVAL_STATUS_EPID_GROUP_REVOKED_BIT_POS
        | 0 << IAS_PSE_EVAL_STATUS_PSDASVN_OUT_OF_DATE_BIT_POS
        | 0 << IAS_PSE_EVAL_STATUS_SIGRL_OUT_OF_DATE_BIT_POS
        | 0 << IAS_PSE_EVAL_STATUS_PRIVRL_OUT_OF_DATE_BIT_POS;
    memset(p_attestation_verification_report->
                info_blob.latest_equivalent_tcb_psvn, 0, PSVN_SIZE);
    memset(p_attestation_verification_report->info_blob.latest_pse_isvsvn,
           0, ISVSVN_SIZE);
    memset(p_attestation_verification_report->info_blob.latest_psda_svn,
           0, PSDA_SVN_SIZE);
    memset(p_attestation_verification_report->info_blob.performance_rekey_gid,
           0, GID_SIZE);

    // @TODO: Product signing algorithm still TBD.  May be RSA2048 signing.
    // Generate the Service providers ECCDH key pair.
    do {
        ret = sample_ecc256_open_context(&ecc_state);
        if (SAMPLE_SUCCESS != ret) {
            fprintf(stderr, "\nError, cannot get ECC cotext in [%s].",
                    __FUNCTION__);
            ret = -1;
            break;
        }
        // Sign
        ret = sample_ecdsa_sign(
                (uint8_t *)&p_attestation_verification_report->
                    info_blob.sample_epid_group_status,
                sizeof(ias_platform_info_blob_t) - sizeof(sample_ec_sign256_t),
                (sample_ec256_private_t *)&g_rk_priv_key,
                (sample_ec256_signature_t *)&p_attestation_verification_report->
                    info_blob.signature,
                ecc_state);
        if (SAMPLE_SUCCESS != ret) {
            fprintf(stderr, "\nError, sign ga_gb fail in [%s].", __FUNCTION__);
            ret = SP_INTERNAL_ERROR;
            break;
        }
        SWAP_ENDIAN_32B(p_attestation_verification_report->
                            info_blob.signature.x);
        SWAP_ENDIAN_32B(p_attestation_verification_report->
                            info_blob.signature.y);

    }while (0);
    if (ecc_state) {
        sample_ecc256_close_context(ecc_state);
    }
    p_attestation_verification_report->pse_status = IAS_PSE_OK;

    // For now, don't simulate the policy reports.
    p_attestation_verification_report->policy_report_size = 0;
    return(ret);
}


// Simulates retrieving the SIGRL for upon the SP request. Becaue the IAS
// backend is not ready right now, we will return NULL.
//
// @param gid Group ID for the EPID key.
// @param p_sig_rl_size Pointer to the output value of the full
//                      SIGRL size in bytes. (including the
//                      signature).
// @param p_sig_rl Pointer to the output of the SIGRL.
//
// @return int

int ias_get_sigrl(
    const sample_epid_group_id_t gid,
    uint32_t *p_sig_rl_size,
    uint8_t **p_sig_rl)
{
    int ret = 0;

    UNUSED(gid);

    do {

        if (NULL == p_sig_rl || NULL == p_sig_rl_size) {
            ret = -1;
            break;
        }
        *p_sig_rl_size = 0;
        *p_sig_rl = NULL;
        // we should try to get sig_rl from IAS, but right now we will just
        // skip it until the IAS backend is ready.
        break;
    }while (0);

    return(ret);
}

//Used to Convert Hex String of SPID to ByteArray
//
//@param str :- SPID in HexString input param
//@param arr :- SPID in BytesArray output param
//@return size of array

int HexStringToByteArray(string str, uint8_t **arr) {
    vector<uint8_t> bytes;

    for (unsigned int i=0; i<str.length(); i+=2) {
        string byteString = str.substr(i, 2);
        char byte = (char) strtol(byteString.c_str(), NULL, 16);
        bytes.push_back((unsigned char)byte);
    }

    *arr = (uint8_t*) malloc(sizeof(uint8_t) * bytes.size());
    copy(bytes.begin(), bytes.end(), *arr);

    return bytes.size();
}

// Used to simulate the enrollment function of the IAS.  It only
// gives back the SPID right now. In production, the enrollment
// occurs out of context from an attestation attempt and only
// occurs once.
//
//
// @param sp_credentials
// @param p_spid
// @param p_authentication_token
//
// @return int

int ias_enroll(
    int sp_credentials,
    sgx_spid_t *p_spid,
    int *p_authentication_token, uint8_t *in_spid)
{
    string str_spid;
    UNUSED(sp_credentials);
    UNUSED(p_authentication_token);

    if (NULL != p_spid) {
        if(in_spid != NULL) {
            str_spid = string((char *)in_spid);
        } else {
                fprintf(stderr, "\nError, SPID not set in env.properties file. Please refer /opt/BarbiE/env.properties file");
                return(1);
            }
        uint8_t *spidBa, spid[16];
        HexStringToByteArray(str_spid, &spidBa);

        for (int i=0; i<16; i++)
            spid[i] = spidBa[i];
        memcpy_s(p_spid, sizeof(sgx_spid_t), &spid,
                 sizeof(sgx_spid_t));
    } else {
        return(1);
    }
    return(0);
}


